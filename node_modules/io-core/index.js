/**
 * Created by Ricardo Morais on 25/02/2017.
 */

/**
 *
 * TODO - VALIDATE SCXML ACTIONCALL ORDERS - The current actionCall do not provide any rules.
 * ActionCalls to 'else' for example require a ActionCall to 'if' as its context for example.
 *
 * TODO - REQUIRED PARAMS - There is a need to create required parameters
 */

/**
 * Uses the sequelize library to connect to a database using the information given, a database library as to be
 * installed and its type should be sent as the dialect
 *
 * # One of the following libraries will suffice:
 * $ npm install --save pg pg-hstore
 * $ npm install --save mysql2
 * $ npm install --save sqlite3
 * $ npm install --save tedious // MSSQL
 *
 * The dialect should be one of the following
 * dialect: 'mysql'|'sqlite'|'postgres'|'mssql',
 *
 * @param dialect A string representing the database technology 'mysql'|'sqlite'|'postgres'|'mssql'
 * @param host The host of the database
 * @param user The user
 * @param password The user password
 * @param database The name of the database
 * @returns {object} Returns an object which interfaces with the database to provide the io-core functionality
 */
module.exports = function (dialect, host, user, password, database) {
    let co = require('co');
    let Sequelize = require('sequelize');
    let sequelize = new Sequelize(database, user, password, {
        host: host,
        dialect: dialect,
        pool: {
            max: 5,
            min: 0,
            idle: 10000
        },
    });

    let moduleName = 'IOCore';
    let meta = {
        sequelize: sequelize,
        name: moduleName,
        action: {
            /**
             * Create an input
             * @param name The name of the input
             * @returns {Promise} A promise that returns the created input
             */
            createInput: function (name) {
                return meta.model.input.create({
                    name: name
                });
            },
            /**
             * TODO - add the require
             * Creates an action
             * @param name The name of the action
             * @param {Array} actionParameters the parameters of the action, an array of object with two properties
             * type(expr) and name, a string representing the name of the parameter
             * @param {Array} childOf An array with the ids of the parent actions
             * @returns {Promise} Returns a promise
             */
            createAction: function (name, actionParameters, childOf) {
                return sequelize.transaction(function (transaction) {
                    return co(function *() {
                        let action = yield meta.model.action.create({
                            name: name
                        }, {transaction: transaction});

                        childOf = childOf || [];
                        for (let parentID of childOf) {
                            yield meta.model.actionChildren.create({
                                actionParentID: parentID,
                                actionChildID: action.dataValues.id
                            }, {transaction: transaction});
                        }

                        for (let parameter of actionParameters) {
                            if (parameter.type !== 'expr') {
                                throw new Error('Type is not valid');
                            }
                            yield meta.model.parameter.create({
                                actionID: action.dataValues.id,
                                name: parameter.name,
                                type: parameter.type
                            }, {transaction: transaction});
                        }
                        return action;
                    });
                });
            },
            /**
             * Creates an action call which represent a call to an action with specific values. On error the
             * transaction will rollback
             * @param {int} actionID The action to call
             * @param {object} valuesMap An object that maps the action parameter names to values
             * @param {int} actionCallID The action call context for example if this action is an 'else' action call
             * there should be an action call named 'if' that envelops it giving it the context
             * @param {int} order in case of many actionCalls in the same context the action must have a ordered
             * sequence; if null the default is 1 in case the order is irrelevant
             * @returns {Promise} Returns a promise
             */
            createActionCall: function (actionID, valuesMap, actionCallID, order) {
                return sequelize.transaction(function (transaction) {
                    return co(function *() {
                        let actionCallObject = {
                            actionID: actionID,
                            actionCallID: actionCallID,
                        };
                        if(order){
                            actionCallObject.order = order;
                        } else {
                            actionCallObject.order = 1;
                        }

                        let actionCall = yield meta.model.actionCall.create(
                            actionCallObject, { transaction: transaction });

                        for (let key of Object.keys(valuesMap)) {
                            let param = (yield meta.model.parameter.findOne({
                                where: {
                                    name: key,
                                    actionID: actionID
                                }
                            }));

                            yield meta.model.value.create({
                                parameterID: param.dataValues.id,
                                actionCallID: actionCall.dataValues.id,
                                value: valuesMap[key]
                            }, {transaction: transaction});
                        }
                        return actionCall;
                    });
                });
            }
        },
        query: {
            /**
             * Gets an action by id
             * @param {number} actionID The action ID
             * @returns {Promise} Returns a promise that returns an action
             */
            getAction: function (actionID) {
                return co(function*() {
                    try {
                        return yield meta.model.action.findOne({
                            where: {
                                id: actionID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the action');
                    }
                })
            },
            /**
             * Gets the parameters of an action by id
             * @param {integer} actionID The action ID
             * @returns {Promise} Returns a promise that return an array of parameters
             */
            getActionParameters: function (actionID) {
                return co(function*() {
                    try {
                        return yield meta.model.parameter.findAll({
                            where: {
                                actionID: actionID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the parameters');
                    }
                })
            },
            /**
             * Gets an actionCall by ID
             * @param {integer} actionCallID The ID of the actionCall
             * @returns {Promise} Returns a promise that returns an actionCall
             */
            getActionCall: function (actionCallID) {
                return co(function*() {
                    try {
                        return yield meta.model.actionCall.findOne({
                            where: {
                                id: actionCallID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the actionCall');
                    }
                })
            },
            /**
             * Gets the values of an actionCall by ID
             * @param {integer} actionCallID The actionCall ID
             * @returns {Promise} Returns a new Promise return an array of values
             */
            getActionCallValues: function (actionCallID) {
                return co(function*() {
                    try {
                        return yield meta.model.value.findAll({
                            where: {
                                actionCallID: actionCallID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the actionCall values');
                    }
                })
            },
            /**
             *  Recursively return an action call hierarchy
             * @param actionCallID action call id
             * @returns {object} Return an object with the action name, its parameters and child actions
             */
            getActionCallHierarchy(actionCallID){
                return co(function*() {
                    let actionCall = yield meta.query.getActionCall(actionCallID);
                    let action = yield meta.query.getAction(actionCall.dataValues.actionID);
                    let result = {
                        action: action.dataValues.name,
                        parameters: {},
                        actions: []
                    };
                    let actionValues = yield meta.query.getActionCallValues(actionCallID);

                    for (let value of actionValues) {
                        let parameter = yield meta.model.parameter.findById(value.dataValues.parameterID);
                        result.parameters[parameter.dataValues.name] = value.dataValues.value;
                    }

                    let children = yield meta.model.actionCall.findAll({
                        where: {
                            actionCallID: actionCallID,
                        }
                    });

                    //todo - be aware of cycles
                    for (let child of children) {
                        let actionCallChild = yield meta.query.getActionCallHierarchy(child.dataValues.id);
                        result.actions.push(actionCallChild);
                    }

                    return result;
                });
            }
        },
        //io-core database model(the IO core meta-model modeled in the database)
        model: {
            input: sequelize.define(moduleName + 'input', {
                name: {type: Sequelize.STRING, allowNull: false, unique: true},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            action: sequelize.define(moduleName + 'action', {
                name: {type: Sequelize.STRING, allowNull: false, unique: true},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            actionChildren: sequelize.define(moduleName + 'actionChildren', {
                actionParentID: {type: Sequelize.INTEGER, allowNull: false},
                actionChildID: {type: Sequelize.INTEGER, allowNull: false},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            parameter: sequelize.define(moduleName + 'parameter', {
                name: {type: Sequelize.STRING, allowNull: false, unique: 'parameter'},
                type: {
                    type: Sequelize.DataTypes.ENUM('expr'),
                    allowNull: false
                },
                actionID: {type: Sequelize.INTEGER, allowNull: false, unique: 'parameter'},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            actionCall: sequelize.define(moduleName + 'actionCall', {
                actionID: {type: Sequelize.INTEGER, allowNull: false},
                order: {type: Sequelize.INTEGER, allowNull: false},
                actionCallID: {type: Sequelize.INTEGER, allowNull: true}
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            value: sequelize.define(moduleName + 'value', {
                parameterID: {type: Sequelize.INTEGER, allowNull: false, unique: 'value'},
                actionCallID: {type: Sequelize.INTEGER, allowNull: false, unique: 'value'},
                value: {type: Sequelize.TEXT, allowNull: false}
            }, {
                freezeTableName: true,
                underscoredAll: true
            })
        }
    };

    //Relations
    meta.model.parameter.belongsTo(meta.model.action, {
        as: 'actionFK',
        foreignKey: 'actionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.value.belongsTo(meta.model.actionCall, {
        as: 'actionCallFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.value.belongsTo(meta.model.parameter, {
        as: 'parameterFK',
        foreignKey: 'parameterID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.actionCall.belongsTo(meta.model.action, {
        as: 'actionFK',
        foreignKey: 'actionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.actionCall.belongsTo(meta.model.actionCall, {
        as: 'actionCallFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.actionChildren.belongsTo(meta.model.action, {
        as: 'actionParentFK',
        foreignKey: 'actionParentID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.actionChildren.belongsTo(meta.model.action, {
        as: 'actionChildFK',
        foreignKey: 'actionChildID',
        constraints: false,
        onDelete: 'CASCADE'
    });

    return co(function*(){
        yield meta.sequelize.sync();
        //https://www.w3.org/TR/2014/CR-scxml-20140313/#4 Executable Content

        try {

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#raise
            yield meta.action.createAction("raise", [
                {name: 'event', type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#if
            let actionIf = yield meta.action.createAction("if", [
                {name: 'cond', type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#elseif
            yield meta.action.createAction("elseif", [ {name: 'cond', type: 'expr'} ], [ actionIf.dataValues.id ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#else
            yield meta.action.createAction("else", [], [ actionIf.dataValues.id ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#foreach
            yield meta.action.createAction("foreach", [
                {name: 'array'  , type: 'expr'},
                {name: 'item'   , type: 'expr'},
                {name: 'index'  , type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#log
            yield meta.action.createAction("log", [
                {name: 'label'  , type: 'expr'},
                {name: 'expr'   , type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#assign
            yield meta.action.createAction("assign", [
                {name: 'location'   , type: 'expr'},
                {name: 'expr'       , type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#script
            yield meta.action.createAction("script", [
                {name: 'src', type: 'expr'},
            ]);

            //https://www.w3.org/TR/2014/CR-scxml-20140313/#send
            yield meta.action.createAction("send", [
                {name: 'event'      , type: 'expr'},
                {name: 'eventexpr'  , type: 'expr'},
                {name: 'target'     , type: 'expr'},
                {name: 'targetexpr' , type: 'expr'},
                {name: 'type'       , type: 'expr'},
                {name: 'typeexpr'   , type: 'expr'},
                {name: 'id'         , type: 'expr'},
                {name: 'idlocation' , type: 'expr'},
                {name: 'delay'      , type: 'expr'},
                {name: 'delayexpr'  , type: 'expr'},
                {name: 'namelist'   , type: 'expr'},
            ]);

            /*
                TODO -  add children
                <param>. The SCXML Processor must evaluate this element when the parent <send> element is evaluated and pass the resulting data to the external service when the message is delivered. Occurs 0 or more times. See 5.7 <param> for details.
                <content>. The SCXML Processor must evaluate this element when the parent <send> element is evaluated and pass the resulting data to the external service when the message is delivered. Occurs 0 or 1 times. See 5.6 <content> for details.0
             */


            //https://www.w3.org/TR/2014/CR-scxml-20140313/#cancel
            yield meta.action.createAction("cancel", [
                {name: 'sendid'     , type: 'expr'},
                {name: 'sendidexpr' , type: 'expr'},
            ]);


            //https://www.w3.org/TR/2014/CR-scxml-20140313/#invoke
            yield meta.action.createAction("invoke", [
                {name: 'type'       , type: 'expr'},
                {name: 'tyoeexpr'   , type: 'expr'},
                {name: 'src'        , type: 'expr'},
                {name: 'srcecpr'    , type: 'expr'},
                {name: 'id'         , type: 'expr'},
                {name: 'idlocation' , type: 'expr'},
                {name: 'namelist'   , type: 'expr'},
                {name: 'autoforward', type: 'expr'},
            ]);


            /*
                TODO -  add children
                <param>. Element containing data to be passed to the external service. Occurs 0 or more times. See 5.7 <param>.
                <finalize>. Element containing executable content to massage the data returned from the invoked component. Occurs 0 or 1 times. See 6.5 <finalize> for details.
                <content>. The SCXML Processor MUST evaluate this element when the parent <invoke> element is evaluated and pass the resulting data to the invoked service. Occurs 0 or 1 times. See 5.6 <content> for details.
             */

        } catch (error) {}

        return meta;
    });

};